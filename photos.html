<!DOCTYPE html>
<html lang="es">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta charset="utf-8">
  <link rel="stylesheet" href="/css/bootstrap.min.css" />
  <title></title>
  <style>
    img{
      max-width: 100%;
      height: auto;
    }
  </style>
  <link rel="stylesheet" href="css/modal.css">
  <!--Los siguientes archivos de la libreria croppie solo se serviran si el usuario va a subir una foto, es decir,
    si el usuario que visualiza el documento photos.html es el propio usuario (el que inicio sesion). Una solucion
    a esto podria ser escribir estos archivos desde el servidor en funcion de si es el usuario propio o no-->
  <link rel="stylesheet" href="croppie/croppie.css"/>
  <script src="croppie/croppie.js"></script>
</head>

<body>

<!--Vista en cuadricula/tabla de las fotos del usuario con sus respectivos botones de borrado + un boton de subida
al final-->
<!--Me pregunto... si en reealidad seria mejor agregar un boton de eliminacion general, y cuando sea pulsado,
	el usuario pueda marcar con una casilla cada foto que desea borrar, asi no tendria un exceso de botones de 
	eliminacion... si, creo que es una mejor opcion de diseño-->

<nav aria-label="breadcrumb">
  <ol class="breadcrumb">
    <li class="breadcrumb-item"><a href="search">Busqueda</a></li>
    <li class="breadcrumb-item"><a href="#">Chat</a></li>
    <li class="breadcrumb-item"><a href="/my-profile">Mi perfil</a></li>
    <li class="breadcrumb-item"><a href="#">Configuracion de la cuenta</a></li>
    <li class="breadcrumb-item"><a href="/logout">Salir</a></li>
  </ol>
</nav>
<div class="img-modal"></div> <!--Se genera una ventana modal cuando el usuario hace click en una  foto-->
<img src="" id="photoView"> <!--Para la vista del recorte de la foto que va a subir el usuario-->
<input  class="form-control" type="file" id="photo" name="photo">
<button id="eliminar" class="btn btn-danger" type="button">Eliminar</button>
<button id="fotoDePerfil" class="btn-success" type="button">Seleccionar foto de perfil</button>
<table class="table">
  <tbody>
    <!--Fotos-->
  </tbody>
</table>
<script>
  function formatearSrc(src){ //Esta funcion se encarga de formatear el src de las imagenes con el fin de enviar solo el nombre de la imagen.
    //El nombre esta despues del primer '/'
    console.log(src);
    let name='', contador=0;
    for (let i=0; i<src.length; i++){
      if (src[i]==='/'){
        contador++;
      }
      if (src[i]!=='/' && contador===4){
        name+=src[i];
      }
    }
    return name;
  }
  /*La siguiente funcion verificara si alguna de las fotos tiene marco. Si una foto i ya lo tiene, entonces se le borrara
  y se le agregara el marco a la foto recibida como segundo parametro. En caso de no haber fotos con marcos, se procede de la 
  misma manera.
  */
  function fotoSeleccionada(arrayFotosDePerfil, fotoASeleccionar){
    for (let i=0; i<arrayFotosDePerfil.length; i++){
      if (arrayFotosDePerfil[i].style.borderColor='green'){ //Son tres parametros de border, pero enrealidad con confirmar uno es suficiente.
        arrayFotosDePerfil[i].style.borderColor=null;
        arrayFotosDePerfil[i].style.borderWidth=null;
        arrayFotosDePerfil[i].style.borderStyle=null;
      }
    }
    fotoASeleccionar.style.borderColor='green';
    fotoASeleccionar.style.borderWidth='5px';
    fotoASeleccionar.style.borderStyle='solid';
  }
  function borrarMarcos(arrayFotosDePerfil){
  	for (let i=0; i<arrayFotosDePerfil.length; i++){
      arrayFotosDePerfil[i].style.borderColor=null;
      arrayFotosDePerfil[i].style.borderWidth=null;
      arrayFotosDePerfil[i].style.borderStyle=null;
    }
  }
  //Codigo para establecer la foto de perfil.
  let fotoDePerfil=document.getElementById('fotoDePerfil');
  fotoDePerfil.addEventListener('click', ()=>{
    let fotos=document.querySelectorAll('img');
    fotos.forEach(foto=>{
      foto.addEventListener('click', ()=>{
        fotoSeleccionada(fotos, foto);
      });
    });
    let confirmarFotoDePerfil=document.createElement('button');
    confirmarFotoDePerfil.textContent='Confirmar foto de perfil';
    document.querySelector('body').appendChild(confirmarFotoDePerfil);
    confirmarFotoDePerfil.addEventListener('click', async ()=>{
      let fotos=document.querySelectorAll('img');
      let i=0, flag=false, nuevaFotoDePerfil;
      while (i<fotos.length && !flag){
        if (fotos[i].style.borderColor==='green'){
          flag=true;
          nuevaFotoDePerfil={src: formatearSrc(fotos[i].src)};
        }
        i++;
      }
      if (flag){
        /*Envio una solicitud para establecer la foto de perfil. Procedere de la siguiente manera:
        En formato json envio el src de la imagen. El servidor se encargara de añadir al src una "etiqueta"
        que servira para identificarla como la foto de perfil. La etiqueta sera "etiquetaFotoDePerfil!x#" y tan solo se
        sumara al src(src+etiqueta). Pero claro, antes debo asegurarme de borrar la etiqueta de la anterior foto de perfil.
        Si no hay etiqueta establecida, entonces procedere de la misma manera.*/
        let request=await fetch('/change-profile-photo', {
        method: 'put',
        headers: {'Content-Type': 'application/json'}, 
        body: JSON.stringify(nuevaFotoDePerfil)});
        let response=await request.json();
        if (response.message==='Foto de perfil cambiada!'){
          /*Selecciono la foto y cambio su src para agregarle la constante. Asi puedo disminuir el error. Una manera que se me 
          ocurre de identifiar la foto de perfil actual (para que al usuario no se elvide) al momento de elegir una nueva
          foto de perfil es agregar un marco de algun color diferente al verde que identifique la foto de perfil actual*/
          alert('Foto de perfil cambiada!');
        } else{
          alert('Error, intentelo de nuevo. Posible causa: Esta intentado cambiar su foto de perfil con su foto de perfil actual o es un error del sistema. En el segundo caso contacte con soporte.');
        }
      }
    });
    let cancelar=document.createElement('button');
    cancelar.textContent='Cancelar';
    document.querySelector('body').appendChild(cancelar);
    cancelar.addEventListener('click', ()=>{
      //Elimino los eventos de las imagenes (añadir marco) y elimino los respectivos botones.
      let fotos=document.querySelectorAll('img');
      borrarMarcos(fotos);
      for (let i=0; i<fotos.length; i++){
        fotos[i].addEventListener('click', ()=>{
          //Creo marcos nulos, asi sustituyo a los eventos que añaden un marco verde.
          fotos[i].style.borderColor=null;
          fotos[i].style.borderWidth=null;
          fotos[i].style.borderStyle=null;
        });
      }
      document.querySelector('body').removeChild(confirmarFotoDePerfil);
      document.querySelector('body').removeChild(cancelar);
    });
  });
  //Ahora el codigo de borrado de fotos...
  let botonDeEliminacion=document.getElementById('eliminar');
  botonDeEliminacion.addEventListener('click', async ()=>{
    //Seleccionare todos los inputs para verficiar si ya han sido creados checkboxs...
    let inputs=document.querySelectorAll('input'), bandera=false;
    for (let i=0; i<inputs.length; i++){
      if (inputs[i].type==='checkbox'){
        bandera=true;
      }
    }
    if (!bandera){
      let table=document.querySelector('table'), cuerpoTabla=table.firstElementChild, filas=cuerpoTabla.children;
      for (let i=0; i<filas.length; i++){
        let filaActual=filas[i], columnas=filaActual.children;
        for (let j=0; j<columnas.length; j++){
          let casilla=document.createElement('input');
          casilla.type='checkbox';
          columnas[j].appendChild(casilla);
        }
      }
      let botonConfirmar=document.createElement('button');
      botonConfirmar.textContent='Confirmar';
      document.querySelector('body').appendChild(botonConfirmar);
      botonConfirmar.addEventListener('click', async ()=>{
        /*Este codigo tendra la funcion de seleccionar las imagenes que el usuario selecciono para ser eliminadas.
        Se enviara al servidor en formato json las rutas de las imagenes para que el servidor se encargue de borrarlas.*/
        let fotos=document.querySelectorAll('img'), inputs=document.querySelectorAll('input'), checkboxes=[];
        console.log(fotos);
        inputs.forEach(input=>{
          if (input.type==='checkbox'){
            checkboxes.push(input);
          }
        });
        let fotosAEliminar=[];
        for (let i=0; i<checkboxes.length; i++){ 
          if (checkboxes[i].checked){
            fotosAEliminar.push(formatearSrc(fotos[i+2].src)); //i+2 porque las primeras dos fotos son la imagen modal y el preview de recorte
          }
        }
        let objetoFotos={
          fotos: fotosAEliminar
        };
        let peticion=await fetch('/photos', {
          method:'delete', 
          headers: {'Content-Type': 'application/json'}, 
          body: JSON.stringify(objetoFotos)
        });
        let respuesta=await peticion.json();
        if (respuesta.message==='Operacion fallida, intentelo de nuevo.'){
          alert('Operacion fallida, intentelo de nuevo.');
        } else{
          alert('Fotos borradas!');
        }
      });
      let botonEliminar=document.createElement('button');
      botonEliminar.textContent='Cancelar';
      document.querySelector('body').appendChild(botonEliminar);
      botonEliminar.addEventListener('click', ()=>{
        //Al ser los checkbox anexados como hijos de las imagenes, entonces se procede a eliminarlos.
        let table=document.querySelector('table'), cuerpoTabla=table.firstElementChild, filas=cuerpoTabla.children;
        for (let i=0; i<filas.length; i++){
          console.log(filas);
          let filaActual=filas[i], columnas=filaActual.children;
          for (let j=0; j<columnas.length; j++){
            columnas[j].removeChild(columnas[j].children[1]); //El checkbox es el segundo hijo de la columa de la fila.
          }
          document.querySelector('body').removeChild(botonConfirmar);
          document.querySelector('body').removeChild(botonEliminar);
        }
      });
    }
  });
</script>
<script src="js/modal.js"></script>
<script>
  initModal("img-modal"); //Initialize Modal by class of modal
  addModal(document.querySelectorAll("img")); // Add Modal to Array of Image/Images
</script>
<script>
  /*Este script servira para usar la libreria croppie con el fin de hacer que el usuario recorte la foto que va a subir
  con las dimensiones especificadas
  Estoy teniendo problemas con la calidad... me pregunto si esto lo podria resolver haciendo enviandole un
  mensaje a los usuarios para que envien una foto de una dimension a<=x<=b donde x es la dimension elegida, a
  la dimension menor aceptada y b la dimension mayor aceptada.*/
  let photo=document.getElementById('photo');
  photo.addEventListener('change', ()=>{
    let objectURL=URL.createObjectURL(photo.files[0]);
    let photoView=document.getElementById('photoView');
    photoView.src=objectURL;
    let vanilla=new Croppie(photoView, {  //ejemplo de vanilla croppie
      viewport: { width: 300, height: 300 },
      boundary: { width: 500, height: 500, type: 'square'},
      //showZoomer: true,
    });
    let enviarFoto=document.createElement('button');
    enviarFoto.textContent='Agregar foto';
    let cancelar=document.createElement('button');
    cancelar.textContent='X';
    enviarFoto.className='btn btn-primary';
    cancelar.className='btn btn-danger';
    //Una solucion que podria usar seria implentar una ruta al momento de que el usuario pulse "X", una ruta hacia la misma pagina...
    /*cancelar.addEventListener('click', ()=>{
      document.querySelector('body').removeChild(vanilla.element);
      document.querySelector('body').removeChild(vanilla.elements);
    });*/
    enviarFoto.style.position='fixed';
    enviarFoto.style.top='20px';
    enviarFoto.style.left='585px';
    enviarFoto.id='uploadPhoto';
    cancelar.style.position='fixed';
    cancelar.style.top='20px';
    cancelar.style.left='700px';
    document.querySelector('body').appendChild(enviarFoto);
    document.querySelector('body').appendChild(cancelar);
    vanilla.element.style.position='fixed';
    vanilla.element.style.top='20px';
    let uploadPhoto=document.getElementById('uploadPhoto');
    uploadPhoto.addEventListener('click', ()=>{
      vanilla.result('blob', 'viewport', 'jpeg', 1).then(async (blob)=>{
        let formdata=new FormData();
        formdata.append('photo', blob); 
        let request=await fetch('/upload-photo',{
          method: 'POST',
          body: formdata
        });
      });
    });
  });
  /*Creo que al momento en que aparezca la foto para recortar, le tendre que añadir dos botones: Enviar foto y 
  cancelar*/
</script>
</body>
</html>

